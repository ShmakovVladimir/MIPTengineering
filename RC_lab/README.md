# Краткий конспект 

## Сохранение данных - _правильная_ запись в файл 

Для получения объекта файла удобно использовать конструкцию `with as`. Данная конструкция хороша тем, что при возникновении какого-либо исключения файл будет закрыт автоматически и данные сохранятся. 

_Пример из_ [_официальной документации к языку python3_](https://docs.python.org/3/):

![alt text](https://github.com/ShmakovVladimir/MIPTengineering/blob/main/RC_lab/synopsis/openFile.png)


Передадим в функцию `open()` модификатор доступа `'w'`, который сообщит, что файл открыт для записи:

`with open(path,'w') as file_obj_name`

Для записи строки в документ, у полученного объекта нужно вызвать метод `.write(any_str)`, который принимает в качестве аргумента строку для записи. 

Очевидно, что запись значения в файл занимает больше времени, чем добавление этого значения в массив. Поэтому именно массив будет содержать все полученные в работе данные.
Для конвертации массива значений в строку для записи воспользуемся методом `join()`:

`'\n'.join(str_array)` 

В результате получим строку типа `val[0]\nval[1]\nval[2]...` - то есть данные из массива построчно запишутся в файл.

## Немного о numpy

- `.array(list)` - создает и возвращает объект array, содержащий значения из списка
- `.ones(size)` - объект array из единиц
- `.zeros(size)` - объект из нулей
- `.empty(size)` - непроинициализированный объект array
- `.arange(start,stop,step)` - обьект array, содержащий числа в диапазоне `[start,end)`. Первое число - `start`, второе - `start+step` ...
- `.linspace(start,stop,q)` - обьект, содержащий `q` чисел в диапазоне `[start,end]`
- `.save(filename,arr)` - сохраняет array в файл 
- `.load(path)` - реконструирует ранее записанный массив

Для объектов типа array определены операции:

- `+` - _матричное_ сложение
- `*` - умножение _матрицы_ на число/cтолбец/строку (метод перегружен для различных аргмуентов)
- `dot()` - матричное умножение(настоящее - по правилам линала)
- `min()` - минимум
- `max()` - максимум 
- `sum()` - сумма элементов


## Немного о matplotlib

- `fig,ax = plt.subplots(q)` - возвращает `tuple`, состоящий из обьекта `figure` и массива объектов `axes`. `q` - количество графиков на данном `fidure`, по умолчанию `q = 1`. В случае `q = 1` вместо массива объектов `axes` получим один объект
- `ax.set_title(title)` - метод объекта `axes`. Задаёт название данного графика. В строке `title` можно пользоваться формуламии Latex.
- `ax.legend()` - наносит легенду на график. Легенду можно настраивать, передавая различные аргументы. Например `loc = 'lower right'` - положение легенды в правом нижнем углу. [Подробное описание метода](https://matplotlib.org/3.5.0/api/_as_gen/matplotlib.pyplot.legend.html)
- `plt.xlabel(label)` - подписывает ось x. Для оси y существует аналогичный метод `.ylabel(label)`
- `plt.grid()` - показать сетку на графике
- `plt.xticks(arr_like)` - нанести вертикальные линии на график. Аналогично для оси y `plt.yticks(arr_like)`.
- `plt.plot(x,y)` - построить график. `x`,`y` - итерируемые объекты - координаты точек по оси `x` и по оси `y` соответственно. Так же может принимать дополнительные аргументы. Например `fmt = '--'` - пунктирный стиль графика(более подробное описание `fmt` ниже). `label` - Название графика, которое будет отображаться на легенде.
	> Полезные стили графиков(аргумент `fmt`):
	- '-'      	просто линия 
	- '--'     	пунктир
	- '-.'      черточка - точечка
	- ':'       точеки 
	- 'o'       кружочки 
	- '_'       крест(если пользоваться методом `.errorbar()` можно наносить кресты погрешностей)

#### Пример использования matplotlib:
![alt text](https://github.com/ShmakovVladimir/MIPTengineering/blob/main/RC_lab/synopsis/example1.png)

Построит 
![alt text](https://github.com/ShmakovVladimir/MIPTengineering/blob/main/RC_lab/synopsis/exp3.png)


