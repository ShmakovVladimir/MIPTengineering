# Краткий конспект 

## Сохранение данных - _правильная_ запись в файл 

Для получения объекта файла удобно использовать конструкцию `with as`. Данная конструкция хороша тем, что при возникновении какого-либо исключения файл будет закрыт автоматически и данные сохранятся. 

_Пример из_ [_официальной документации к языку python3_](https://docs.python.org/3/):

![alt text](https://github.com/ShmakovVladimir/MIPTengineering/blob/main/RC_lab/synopsis/openFile.png)


Передадим в функцию `open()` модификатор доступа `'w'`, который сообщит, что файл открыт для записи:

`with open(path,'w') as file_obj_name`

Для записи строки в документ, у полученного объекта нужно вызвать метод `.write(any_str)`, который принимает в качестве аргумента строку для записи. 

Очевидно, что запись значения в файл занимает больше времени, чем добавление этого значения в массив. Поэтому именно массив будет содержать все полученные в работе данные.
Для конвертации массива значений в строку для записи воспользуемся методом `join()`:

`'\n'.join(str_array)` 

В результате получим строку типа `val[0]\n_val[1]\nval[2]...` - то есть данные из массива построчно запишутся в файл.

## Немного о numpy

- `.array(list)` - создает и возвращает объект array, содержащий значения из списка
- `.ones(size)` - объект array из единиц
- `.zeros(size)` - объект из нулей
- `.empty(size)` - непроинициализированный объект array
- `.arange(start,stop,step)` - обьект array, содержащий числа в диапазоне `[start,end)` 
первое число - `start`, второе - `start+step` ...
- `.linspace(start,stop,q)` - обьект, содержащий `q` чисел в диапазоне `[start,end)`
- `.save(filename,arr)` - сохраняет array в файл 
- `.load(path)` - реконструирует ранее записанный массив

Для объектов типа array определены операции:

- `+` - _матричное_ сложение
- `*` - умножение _вектора_ на число или _матричное умножение_(метод перргружен для различных аргументов)
- `dot()` - матричное умножение(настоящее - по правилам линала)
- `min()` - минимум
- `max()` - максимум 
- `sum()` - сумма элементов



